// Generated by CoffeeScript 1.8.0
(function() {
  var GeolocationService, services,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  services = angular.module("commons.commonsdevmap.services", []);

  services.constant("options", {
    enableHighAccuracy: false,
    maximumAge: 60000,
    timeout: 5000
  });

  GeolocationService = (function() {
    "A geolocation service to get and watch user position";
    function GeolocationService($q, $rootScope, $window, options) {
      this.$q = $q;
      this.$rootScope = $rootScope;
      this.$window = $window;
      this.options = options;
      this.resolveLatLng = __bind(this.resolveLatLng, this);
      this.lookupAddress = __bind(this.lookupAddress, this);
      this.cancelWatchPosition = __bind(this.cancelWatchPosition, this);
      this.watchPosition = __bind(this.watchPosition, this);
      this.position = __bind(this.position, this);
      if (!this.$window.navigator.geolocation) {
        console.warn("Geolocation not supported.");
      }
      this.geocoder = new google.maps.Geocoder();
      this.watchId = null;
      this.$rootScope.position = {};
      this.$rootScope.isGeolocating = false;
    }

    GeolocationService.prototype.position = function() {
      var deferred;
      this.$rootScope.isGeolocating = true;
      deferred = this.$q.defer();
      this.$window.navigator.geolocation.getCurrentPosition((function(_this) {
        return function(pos) {
          return _this.$rootScope.$apply(function() {
            _this.$rootScope.isGeolocating = false;
            return deferred.resolve(angular.copy(pos));
          });
        };
      })(this), (function(_this) {
        return function(error) {
          return _this.$rootScope.$apply(function() {
            _this.$rootScope.isGeolocating = false;
            return deferred.reject(error);
          });
        };
      })(this), this.options);
      return deferred.promise;
    };

    GeolocationService.prototype.watchPosition = function(callback) {
      "watch current position of user";
      console.debug("Watching user location...");
      return this.watchId = this.$window.navigator.geolocation.watchPosition(callback, function() {
        return console.debug("error while getting position");
      }, {
        enableHighAccuracy: true,
        maximumAge: 1000,
        timeout: 3000
      });
    };

    GeolocationService.prototype.cancelWatchPosition = function() {
      "Cancel watching user position";
      return this.$window.navigator.geolocation.clearWatch(this.watchId);
    };

    GeolocationService.prototype.lookupAddress = function(location) {
      var deferred;
      deferred = this.$q.defer();
      this.geocoder.geocode({
        'address': location
      }, (function(_this) {
        return function(results, status) {
          var latLong;
          if (status === google.maps.GeocoderStatus.OK) {
            latLong = [results[0].geometry.location.lat(), results[0].geometry.location.lng(), results[0].geometry.viewport];
            return _this.$rootScope.$apply(function() {
              return deferred.resolve(angular.copy(latLong));
            });
          } else {
            return _this.$rootScope.$apply(function() {
              return deferred.reject(status);
            });
          }
        };
      })(this));
      return deferred.promise;
    };

    GeolocationService.prototype.resolveLatLng = function(lat, lng) {
      var deferred, latlng;
      deferred = this.$q.defer();
      latlng = new google.maps.LatLng(lat, lng);
      this.geocoder.geocode({
        'latLng': latlng
      }, (function(_this) {
        return function(results, status) {
          if (status === google.maps.GeocoderStatus.OK) {
            if (results[0]) {
              return _this.$rootScope.$apply(function() {
                return deferred.resolve(angular.copy(results[0]));
              });
            }
          } else {
            return _this.$rootScope.$apply(function() {
              return deferred.reject(status);
            });
          }
        };
      })(this));
      return deferred.promise;
    };

    return GeolocationService;

  })();

  services.factory('debounce', [
    '$timeout', function($timeout) {
      return function(fn, timeout, apply) {
        var nthCall, _ref, _ref1;
        timeout = (_ref = angular.isUndefined(timeout)) != null ? _ref : {
          0: timeout
        };
        apply = (_ref1 = angular.isUndefined(apply)) != null ? _ref1 : {
          "true": apply
        };
        nthCall = 0;
        return function() {
          var argz, later, that;
          that = this;
          argz = arguments;
          nthCall++;
          later = (function(version) {
            return function() {
              if (version === nthCall) {
                return fn.apply(that, argz);
              }
            };
          })(nthCall);
          return $timeout(later, timeout, apply);
        };
      };
    }
  ]);

  services.service("geolocation", ["$q", "$rootScope", "$window", "options", GeolocationService]);

}).call(this);
